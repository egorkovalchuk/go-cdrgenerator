
// ************************************************************************
// DIAMETER MESSAGE HEADER
// ************************************************************************
	// ====================================================
	// == diameter MESSAGE HEADER SIZE == (RFC3588-3)
	// ====================================================
	const uint MSG_HEADER_SIZE = 0x14;

	// ====================================================
	// == diameter message PROTOCOL VERSION == (RFC3588-3)
	// ====================================================
	enum VERSION
	{
		VER1 = 1 		// Always Version 1
	};

	// ====================================================
	// == diameter message COMMAND FLAGS ==	(RFC3588-3)
	// ====================================================
	enum COMMAND_FLAGS
	{
		R_mask = 128,	// Request flag
		P_mask = 64,	// Proxiable flag
		E_mask = 32,	// Error flag
		T_mask = 16,	// reTransmitted flag
		NO_mask= 0		// No flags at all
	};

	// ====================================================
	// == diameter message "COMMAND CODE" (IANA cons.) ==	
	// ====================================================
	typedef unsigned int COMMANDCODE;

	// ====================================================
	// == diameter message "APPLICATION ID" (IANA cons.) ==	
	// ====================================================
	typedef unsigned int APPID;
	enum APPL_ID	
	{	DIAMCM	= 0,	// Diameter Common Messages (RFC3588-11.2.2)
		NASREQ	= 1,	// NASREQ					(RFC3588-11.2.2)
		DIAMIP	= 2,	// Mobile-IP				(RFC3588-11.2.2)	
		DIAMBA	= 3,	// Diameter Base Acounting	(RFC3588-11.2.2)
		DIAMCC	= 4 	// Diameter Credit Control	(RFC4006-12.1)
	};

	// ====================================================
	// == diameter message "HOP-BY-HOP-IDENTIFIER" == (RFC3588-3)
	// ====================================================
	typedef	unsigned int HopByHop;

	// ====================================================
	// == diameter message "END-TO-END-IDENTIFIER" == (RFC3588-3)
	// ====================================================
	typedef	unsigned int EndToEnd;

	struct MESSAGE_HEADER
	{
		VERSION			version;
		uint			size;
		uint			t_mask;
		bool			e_bit;
		uint			r_mask;
		COMMANDCODE		command_code;
		APPID			appl_id;
		HopByHop		hop_by_hop;
		EndToEnd		end_to_end;

		MESSAGE_HEADER() : 
			version(VER1),
			size(MSG_HEADER_SIZE),
			t_mask(0),
			e_bit(false),
			r_mask(0),
			command_code(0),
			appl_id(DIAMCM),
			hop_by_hop(0),
			end_to_end(0)
		{}

		MESSAGE_HEADER(COMMANDCODE command, uint hbh, uint ete) : 
			version(VER1),
			size(MSG_HEADER_SIZE),
			t_mask(0),
			e_bit(false),
			r_mask(0),
			command_code(command),
			appl_id(DIAMCM),
			hop_by_hop(hbh),
			end_to_end(ete)
		{}

		MESSAGE_HEADER(const byte * buf) : 
			version((VERSION)buf[0x00]),
			size(ntot(&buf[0x01])),
			t_mask((buf[0x04] & T_mask) != 0),
			e_bit((buf[0x04] & E_mask) != 0),
			r_mask((buf[0x04] & R_mask)),
			command_code(ntot(&buf[0x05])),
			appl_id(ntol(&buf[0x08])),
			hop_by_hop(ntol(&buf[0x0C])),
			end_to_end(ntol(&buf[0x10]))
		{}
	};

	// ************************************************************************
// DIAMETER AVP HEADER (WARNINING: Security & Vendor-ID is not supported)
// ************************************************************************
	// ====================================================
	// == diameter AVP HEADER SIZE == (RFC3588-4.1)
	// ====================================================
	const uint AVP_HEADER_SIZE = 0x08;

	// == diameter AVP FLAGS ==	(RFC3588-4.1) 
	typedef unsigned char AVPFLAGBITS;
	// ====================================================
	// == diameter AVP FLAGS ==	(RFC3588-4.1) 
	// ====================================================
	enum AVP_FLAG_BITS
	{	V_bits = (AVPFLAGBITS) 128,	// Vendor specific bit
		M_bits = (AVPFLAGBITS) 64,	// Mandatory bit
		P_bits = (AVPFLAGBITS) 32	// Encryption bit
	};

	// == diameter AVP CODE ==	(RFC3588-4.1) 
	typedef unsigned int AVPCODE;


	// ====================================================
	// == diameter AVP HEADER, representing decoding ==	(RFC3588-4.1) 
	// ====================================================

	struct AVP_HEADER
	{
		AVPCODE		avp_code;
		AVPFLAGBITS	avp_flag_bits;
		uint		avp_length;

		AVP_HEADER(const byte * buf, uint &index) : 
			avp_code(ntol(&buf[0x00 + index])),				//[x00 - x03] AVP-Code
			avp_flag_bits(buf[0x04 + index]),				//[x04 - x04] AVP Flags
			avp_length (uint(ntot(&buf[0x05 + index])))	//[x05 - x07] AVP-Length 
		{
			index += AVP_HEADER_SIZE + (avp_flag_bits & V_bits ? 4 : 0);
		}
	};
}; // END DIAM namespace


enum ScenarioStates
{
	WAIT_FOR_CHRISTMAS		= 0,
	WAIT_FOR_CCR_INITIAL	= 1,
	WAIT_FOR_CCA_INITIAL	= 2,
	WAIT_FOR_CCR_UPDATE		= 3,
	WAIT_FOR_CCA_UPDATE		= 4,
	WAIT_FOR_CCR_TERMINATE	= 5,
	WAIT_FOR_CCA_TERMINATE	= 6,
	WAIT_FOR_CONTEXT		= 7,
	WAIT_FOR_CONTEXT_EST	= 8,
	WAIT_FOR_CONTEXT_CLOSE	= 9,
	NEED_TO_PROCESS			= 10
};

enum QuotaHandlingMode
{
	ALL_IN_ONE				= 0,
	ON_DMD					= 1,
	INDEP_ON_DMD			= 2,
	INDEP_ON_DMD_NO_MPX		= 3
};

struct CPacketConfig
{
	std::string	szName;
	bool		bPresent;

	CPacketConfig(char* name, bool flag) :
		szName(name)
		, bPresent(flag)
	{}
};

typedef std::map<DIAM::AVP, CPacketConfig>	PacketConfigMap;
typedef PacketConfigMap::iterator		PacketConfigMapIter;

struct DiameterData
{
	struct _scenario
	{
		std::string session_id;
		std::string subscriber_id;
		std::string	service_context_id;

		uint		id;
		uint		result_code;
		uint		request_number;
		uint		request_type;
		uint		control_request_type;

		bool		deleting_initiated;
		
		DIAM::MS_INDICATOR		multiple_service_indicator;
		DIAM::CHARGING_SCENARIO	charging_scenario;
		DIAM::REQUESTED_ACTION	requested_action;

		time_t		event_timestamp;

		struct _subscription_id_list
		{
			uint	num;
			
			struct _subscription_id
			{
				DIAM::END_USER	subscription_id_type;
				std::string		subscription_id_data;

				_subscription_id() :
					subscription_id_type(DIAM::END_USER_IMSI),
					subscription_id_data()
				{}		
			} subscription_id[5];

			_subscription_id_list() :
				num(0)
			{}		

		} subscription_id_list;

		struct _mscc_list
		{
			uint	num;
			double	percent_completed;
			rg_pair	num_by_rg;

			struct _fbc
			{
				bool	context_present;
				double	wait_timeout;
				
				ScenarioStates		state_id;

				_fbc() :
					context_present(false),
					wait_timeout(0),
					state_id(WAIT_FOR_CONTEXT)
				{}
			} fbc;
			
			struct _multiple_service_credit_control
			{
				bool	present;
				uint	rating_group;
				uint	reporting_reason;
				uint	validity_time;
				uint	result_code;
				std::string	user_data;

				struct _internal
				{
					DIAM::QUOTA_TYPE	quota_type;
					ScenarioStates		state_id;
					ulong				volume_to_use;
					double				wait_timeout;
					uint				times_left;
					uint				use_n_times;
					bool				ready;
					
					_internal() :
						quota_type(DIAM::SERVICE_SPECIFIC_UNITS),
						state_id(WAIT_FOR_CHRISTMAS),
						volume_to_use(1),
						wait_timeout(0.66),
						times_left(1),
						use_n_times(1),
						ready(false)
					{}

					char* qt2str()
					{
						switch (quota_type)
						{
						case DIAM::TIME: return "TIME";
						case DIAM::INPUT_OCTETS:
						case DIAM::OUTPUT_OCTETS:
						case DIAM::TOTAL_OCTETS: return "OCTETS";
						case DIAM::SERVICE_SPECIFIC_UNITS: return "UNITS";
						case DIAM::MONEY: return "MONEY";
						default: return "UNKNOWN";
						}
					}

					double quota2timeout(ulong quota)
					{
						double timeout = (double)quota;
						switch (quota_type)
						{
						case DIAM::TIME:
						case DIAM::SERVICE_SPECIFIC_UNITS: return timeout;
						case DIAM::INPUT_OCTETS:
						case DIAM::OUTPUT_OCTETS:
						case DIAM::TOTAL_OCTETS: return (timeout / 1024);
						case DIAM::MONEY: return (timeout / 10);
						default: return timeout;
						}
					}

				} internal;

				struct _granted_service_unit
				{
					bool	present;
					ulong	value;
				
					_granted_service_unit() 
						: present(false)
						, value(0)
				{}

				} granted_service_unit;

				struct _used_service_unit
				{
					bool	present;
					ulong	value;

					_used_service_unit() 
						: present(false)
						, value(0)
				{}
				} used_service_unit;

				struct _requested_service_unit
				{
					bool	present;
					ulong	value;
					uint	quota_type;

					_requested_service_unit() 
						: present(true)
						, value(0)
						, quota_type(5)
					{}
				} requested_service_unit;

				_multiple_service_credit_control()
					: present(false)
					, rating_group(1)
					, reporting_reason(DIAM::NO_REASON)
					, validity_time(0)
					, result_code(0)
					, user_data("<service-id>MF100x100PICS</service-id>")
					//<wap-service><service-id>MF100x100PICS</service-id><type-id>PICTURE</type-id><content-id>12344Q34R</content-id><size>14543</size><url>http://wap.megafonpro.ru/is3nwp/cs/01/incore/video/top/?t=buy&amp;cid=0001&amp;fid=03</url></wap-service>
				{}

			} mscc[10];

			_mscc_list() :
				num(0),
				percent_completed(0)
			{}

			ulong get_usu(uint num) { return mscc[num].used_service_unit.value; }
			ulong get_gsu(uint num) { return mscc[num].granted_service_unit.value; }

			uint get_min_timeout()
			{
				uint timeout = 0xFFFF;
				for (uint i = 0; i < num; i++)
				{
					uint min_val = 0;
					if (mscc[i].granted_service_unit.present)
					{
						min_val = (uint)min(get_gsu(i), mscc[i].internal.volume_to_use);
						timeout = min(timeout, min_val);
					}
				}
				return timeout;
			}

		} mscc_list;

		_scenario(char* subs_id = "") 
			: session_id("")
			, subscriber_id(subs_id)
			, service_context_id("250.02.6.32270@3gpp.org")
			, id(0)
			, result_code(2001)
			, request_number(0)
			, request_type(0)
			, control_request_type(0)
			, multiple_service_indicator(DIAM::MS_SUPPORTED)
			, charging_scenario(DIAM::ECUR)
			, requested_action(DIAM::DIRECT_DEBITING)
			, event_timestamp(0)
			, deleting_initiated(false)
		{}
	} scenario;
	
	PacketConfigMap packet_config;
};

struct SubscriptionId
{
	DIAM::END_USER	SubscriptionIdType;
	std::string		SubscriptionIdData;

	SubscriptionId(int type, char* data) 
		: SubscriptionIdType((DIAM::END_USER)type)
		, SubscriptionIdData(data)
	{}		
};

struct ServiceParameterInfo
{
	bool Present;
	int ServiceParameterType;
	std::string ServiceParameterValue;

	ServiceParameterInfo(int type, char* value)
		: ServiceParameterType(type)
		, ServiceParameterValue(value)
	{}

	ServiceParameterInfo()
		: ServiceParameterType(0)
		, ServiceParameterValue("")
	{}

	void SetPresent()
	{
		Present = ServiceParameterType > 0
			   || !ServiceParameterValue.empty();
	}
};

struct UserEquipmentInfo
{
	bool Present;
	int UserEquipmentInfoType;
	std::string UserEquipmentInfoValue;

	UserEquipmentInfo(int type, char* value)
		: UserEquipmentInfoType(type)
		, UserEquipmentInfoValue(value)
	{}

	UserEquipmentInfo()
		: UserEquipmentInfoType(0)
		, UserEquipmentInfoValue("")
	{}

	void SetPresent()
	{
		Present = UserEquipmentInfoType >=0
			   || !UserEquipmentInfoValue.empty();
	}
};

struct VendorSpecificInformation
{
	bool Present;
	std::string RullbaseId;
	std::string RullSpaceSuggestion;

	VendorSpecificInformation(char* _RullbaseId, char* _RullSpaceSuggestion)
		: RullbaseId(_RullbaseId)
		, RullSpaceSuggestion(_RullSpaceSuggestion)
	{}

	VendorSpecificInformation()
		: RullbaseId("")
		, RullSpaceSuggestion("")
	{}

	void SetPresent()
	{
		Present = !RullbaseId.empty()
			|| !RullSpaceSuggestion.empty();
	}

};

struct MultipleService
{
	int ServiceIdentifier;
	int RatingGroup;
	DIAM::QUOTA_TYPE QuotaType;
	bool ExternalQuoting;
	ulong Volume;
	double Timeout;
	std::string UserData;
	std::string SpecificData;
	int SpecificType;
	int AccountType;
	int ServiceContentType;

	ulong VolumeGranted;
	ulong VolumeLastUsed;
	ulong VolumeTotalUsed;
	ulong VolumeToUse;
	ulong QuotaSize;
	double WaitTimeout;
	uint VolumePerSecond;

	uint ResultCode;

	bool Completed;
	bool NeedReportProgress;

	MultipleService() 
		: ServiceIdentifier((uint)-1)
		, RatingGroup((uint)-1)
		, QuotaType(DIAM::QUOTA_TYPE::SERVICE_SPECIFIC_UNITS)
		, ExternalQuoting(false)
		, Volume(0)
		, Timeout(0)
		, SpecificType((uint)-1)
		, VolumeGranted(0)
		, VolumeLastUsed(0)
		, VolumeTotalUsed(0)
		, VolumeToUse(0)
		, QuotaSize(0)
		, WaitTimeout(0)
		, ResultCode(DIAM::RESULT_CODE::SUCCESS)
		, Completed(false)
		, NeedReportProgress(true)
		, AccountType(0)
		, ServiceContentType(0)
	{}		

	MultipleService(int si, int rg, int qt, bool external, ulong volume, ulong quota, double timeout, char* userData, char* specificData, int specificType) 
		: ServiceIdentifier(si)
		, RatingGroup(rg)
		, QuotaType((DIAM::QUOTA_TYPE)qt)
		, ExternalQuoting(external)
		, Volume(volume)
		, Timeout(timeout)
		, VolumeGranted(0)
		, VolumeLastUsed(0)
		, VolumeTotalUsed(0)
		, VolumeToUse(volume)
        , QuotaSize(external ? volume : quota)
		, WaitTimeout(timeout)
		, ResultCode(DIAM::RESULT_CODE::SUCCESS)
		, Completed(false)
		, NeedReportProgress(true)
		, UserData(userData)
		, SpecificData(specificData)
		, SpecificType(specificType)
	{}		

	void Reset()
	{
		VolumeGranted = 0;
		VolumeLastUsed = 0;
		VolumeTotalUsed = 0;
		VolumeToUse = Volume;
		WaitTimeout = Timeout;
		ResultCode = DIAM::RESULT_CODE::SUCCESS;
		Completed = false;
		NeedReportProgress = true;
		AccountType = 0;
		ServiceContentType = 0;
	}
};*/

//typedef std::map<std::pair<uint/*rg*/, uint/*si*/>, MultipleService> MultipleServiceMap;
/*
struct GPP3PSInformation
{
	bool Present;
    int Gpp3PdpType;
	std::string Gpp3ChargingId;
    std::string PdpAddress;
    std::string SgsnAddress;
    std::string GgsnAddress;
    std::string Gpp3Nsapi;
    std::string CalledStationId;
    std::string Gpp3SelectionMode;
    std::string Gpp3ChargingCharacteristics;
    bool Gpp3MsTimeZonePresent;
    int Sign;
    int TimeZone;
    int DaylightSavingTime;
    std::string ChagingRuleBaseName;
	std::string Gpp3ImsiMccMnc;
	std::string Gpp3SgsnMccMnc;
	std::string Gpp3GprsNegotiatedQosProfile;
    bool Gpp3UserLocationInfoPresent;
    std::string Mcc;
    std::string Mnc;
    int Area;
    int Cell;

	void SetPresent()
	{
		Gpp3MsTimeZonePresent = (TimeZone || DaylightSavingTime);
		Gpp3UserLocationInfoPresent = (!Mcc.empty() || !Mcc.empty() || Area || Cell);
		Present = Gpp3PdpType >=0
			   || !Gpp3ChargingId.empty()
			   || !PdpAddress.empty()
			   || !SgsnAddress.empty()
			   || !GgsnAddress.empty()
			   || !Gpp3Nsapi.empty()
			   || !CalledStationId.empty()
			   || !Gpp3SelectionMode.empty()
			   || !Gpp3ChargingCharacteristics.empty()
			   || Gpp3MsTimeZonePresent
			   || !ChagingRuleBaseName.empty()
			   || !Gpp3ImsiMccMnc.empty()
			   || !Gpp3SgsnMccMnc.empty()
			   || !Gpp3GprsNegotiatedQosProfile.empty()
			   || Gpp3UserLocationInfoPresent;
	}
};

struct ServiceVoiceInformation
{
    bool Present;
    bool ATimeZonePresent;
    int ASign;
    int ATimeZone;
    int ADaylightSavingTime;	
    std::string AMCC;
    std::string AMNC;
    int AArea;
    int ACell;
    int ARoaming;
    std::string AGlobalTitle;
    int SubscriptionBIdType;    
    std::string SubscriptionBIdData;
    bool BTimeZonePresent;
    int BSign;
    int BTimeZone;
    int BDaylightSavingTime;	
    int SubscriptionCIdType;
    std::string SubscriptionCIdData;

	void SetPresent()
	{
		ATimeZonePresent = (ATimeZone || ADaylightSavingTime);
		BTimeZonePresent = (BTimeZone || BDaylightSavingTime);
		Present = ATimeZonePresent
			|| !AMCC.empty()
			|| !AMNC.empty()
			|| AArea
			|| ACell
			|| ARoaming >= 0
			|| !AGlobalTitle.empty()
			|| SubscriptionBIdType >= 0
			|| !SubscriptionBIdData.empty()
			|| BTimeZonePresent
			|| SubscriptionBIdType >= 0
			|| !SubscriptionBIdData.empty();
	}
};

struct GPP3MMSInformation
{
	bool Present;
    std::string RecipientAddress;

	void SetPresent()
	{
		Present = !RecipientAddress.empty();
	}
};


struct GPP3SMSInformation
{
	bool Present;

	bool RootFieldsPresent;
    int SmsNode;
    std::string ClientAddress;
    std::string OriginatorSccpAddress;
    std::string SmscAddress;
    int DataCodingScheme;
    std::string SmDischargeTime;
    int SmMessageType;

    //OriginatorInterface;
	bool OriginatorInterfacePresent;
    std::string InterfaceId;
    std::string InterfacePort;
    std::string InterfaceText;
    int OriginatorInterfaceType;

    std::string SmProtocolId;
    int ReplyPathRequested;
    std::string SmStatus;
    std::string SmUserDataHeader;
    unsigned int NumberOfMessagesSent;
    
	//RecipientInfo;
	bool RecipientInfoPresent;
	bool DestinationInterfacePresent;
    std::string DestinationInterfaceId;
    std::string DestinationInterfacePort;
    std::string DestinationInterfaceText;
    int DestinationInterfaceType;

	bool RecipientAddressPresent;
    std::string RecipientAddressData;
    std::string RecipientAddressDomainName;
    std::string RecipientAddressGpp3ImsiMccMnc;
    int RecipientAddressType;
    int RecipientAddresseeType;

	bool RecipientReceivedAddressPresent;
    std::string RecipientReceivedAddressData;
    std::string RecipientReceivedAddressDomainName;
    std::string RecipientReceivedAddressGpp3ImsiMccMnc;
    int RecipientReceivedAddressType;

    std::string RecipientSccpAddress;
    
    std::string RecipientSmProtocolId;

    //OriginatorReceivedAddress;
	bool OriginatorReceivedAddressPresent;
    std::string AddressData;
    std::string DomainName;
    std::string Gpp3ImsiMccMnc;
    int AddressType;

	int SmServiceType;

	void SetPresent()
	{
		RootFieldsPresent = SmsNode >= 0 || DataCodingScheme >= 0 || SmMessageType >= 0 || ReplyPathRequested >= 0 || NumberOfMessagesSent >= 0 || SmServiceType >= 0
			|| !ClientAddress.empty() 
			|| !OriginatorSccpAddress.empty() 
			|| !SmscAddress.empty() 
			|| !SmDischargeTime.empty()
			|| !SmProtocolId.empty()
			|| !SmStatus.empty()
			|| !SmUserDataHeader.empty();
			
		OriginatorInterfacePresent = !InterfaceId.empty() || !InterfacePort.empty() || !InterfaceText.empty() || OriginatorInterfaceType >= 0;
		OriginatorReceivedAddressPresent = !AddressData.empty() || !DomainName.empty() || !Gpp3ImsiMccMnc.empty() || AddressType >= 0;

		DestinationInterfacePresent = !DestinationInterfaceId.empty() || !DestinationInterfacePort.empty() || !DestinationInterfaceText.empty() || DestinationInterfaceType >= 0;
		RecipientAddressPresent = !RecipientAddressData.empty() || !RecipientAddressDomainName.empty() || !RecipientAddressGpp3ImsiMccMnc.empty() || RecipientAddressType >= 0 || RecipientAddresseeType >= 0;
		RecipientReceivedAddressPresent = !RecipientReceivedAddressData.empty() || !RecipientReceivedAddressDomainName.empty() || !RecipientReceivedAddressGpp3ImsiMccMnc.empty() || RecipientReceivedAddressType >= 0;

		RecipientInfoPresent = DestinationInterfacePresent || RecipientAddressPresent || RecipientReceivedAddressPresent || !RecipientSccpAddress.empty() || !RecipientSmProtocolId.empty();

		Present = OriginatorInterfacePresent || RecipientInfoPresent || OriginatorReceivedAddressPresent || RootFieldsPresent;
	}
};


struct ServiceProfile
{
	DWORD MessageId;

	bool Completed;
	bool WaitingForRequest;
	bool WaitingForResponse;
	bool WaitingForProcessing;
	std::string ServiceContextId;
	DIAM::APPL_ID InterfaceType;
	DIAM::REQUEST_TYPE RequestType;
	DIAM::REQUESTED_ACTION RequestedAction;
	DIAM::MS_INDICATOR MultipleServiceIndicator;

	int ServiceInformationType;

	GPP3PSInformation PSInformation;
	GPP3MMSInformation	MMSInformation;
	GPP3SMSInformation SMSInformation;

	ServiceVoiceInformation SVInformation;

	std::list<SubscriptionId> SubscriptionIdList;
	MultipleServiceMap MultipleServices;

	ServiceParameterInfo SPInformation;
	UserEquipmentInfo UEInformation;

	VendorSpecificInformation VPInformation;

	int TerminationCause;
	int BisSubscriberIdSupport;

	std::string SessionId;
	uint RequestNumber;
	uint ServerIndex;

	int RepeatCount;

	int ResultCode;
	
	MultipleService* pCurrent;

	LARGE_INTEGER SendTime;
	double ProcessTime;

	ServiceProfile()
		: Completed(false)
		, WaitingForRequest(true)
		, WaitingForResponse(false)
		, WaitingForProcessing(false)
		, pCurrent(NULL)
		, ResultCode(DIAM::RESULT_CODE::SUCCESS)
		, RequestNumber(0)
		, ServerIndex(-1)
		, RepeatCount(0)
		, ProcessTime(0)
		, ServiceInformationType(0)
		, TerminationCause(0)
		, BisSubscriberIdSupport(0)
	{
		SendTime.QuadPart = 0;
	}

	bool CheckTimeout(double delta)
	{
		pCurrent->WaitTimeout -= delta;
		return pCurrent->WaitTimeout <= 0;
	}

	void Reset()
	{
		SendTime.QuadPart = 0;
		Completed = false;
		WaitingForRequest = true;
		WaitingForResponse = false;
		WaitingForProcessing = false;
		ResultCode = DIAM::RESULT_CODE::SUCCESS;
		RequestNumber = 0;
		ServerIndex = -1;
		ProcessTime = 0;
		TerminationCause = 0;
		MessageId = InterfaceType == DIAM::APPL_ID::DIAMBA ? 30 : 40;
		if (RequestType != DIAM::REQUEST_TYPE::EVENT_REQUEST)
			RequestType = DIAM::REQUEST_TYPE::INITIAL_REQUEST;

		MultipleServiceMap::iterator it = MultipleServices.begin();

		for (; it != MultipleServices.end(); ++it)
		{
			it->second.Reset();
		}

		BisSubscriberIdSupport = 0;
	}
};
// USHORT_16 -> NET
inline void ston(unsigned short u, byte *buf)
{
	*(((byte*)buf)+0)	= *(((byte*)&u)+1);
	*(((byte*)buf)+1)	= *(((byte*)&u)+0);
};
// TRIPLET_24 -> NET
inline void tton(unsigned int u, byte *buf)		
{
	*(((byte*)buf)+0)	= *(((byte*)&u)+2);
	*(((byte*)buf)+1)	= *(((byte*)&u)+1);
	*(((byte*)buf)+2)	= *(((byte*)&u)+0);
}
// UINT_32 -> NET
inline void lton(unsigned int u, byte *buf)		
{
	*(((byte*)buf)+0)	= *(((byte*)&u)+3);
	*(((byte*)buf)+1)	= *(((byte*)&u)+2);
	*(((byte*)buf)+2)	= *(((byte*)&u)+1);
	*(((byte*)buf)+3)	= *(((byte*)&u)+0);
}
// ULONG_64 -> NET
inline void llton(unsigned long long u, byte *buf)		
{
	*(((byte*)buf)+0)	= *(((byte*)&u)+7);
	*(((byte*)buf)+1)	= *(((byte*)&u)+6);
	*(((byte*)buf)+2)	= *(((byte*)&u)+5);
	*(((byte*)buf)+3)	= *(((byte*)&u)+4);

	*(((byte*)buf)+4)	= *(((byte*)&u)+3);
	*(((byte*)buf)+5)	= *(((byte*)&u)+2);
	*(((byte*)buf)+6)	= *(((byte*)&u)+1);
	*(((byte*)buf)+7)	= *(((byte*)&u)+0);
}

// NET -> USHORT_16
inline unsigned short ntos(const void* lpBytes)
{
	unsigned short val;	
	*(((byte*)&val)+0) = *(((byte*)lpBytes)+1);
	*(((byte*)&val)+1) = *(((byte*)lpBytes)+0);
	return val;
}
// NET -> TRIPLET_24
inline unsigned int ntot(const void* lpBytes)
{
	unsigned int val;	
	*(((byte*)&val)+0) = *(((byte*)lpBytes)+2);
	*(((byte*)&val)+1) = *(((byte*)lpBytes)+1);
	*(((byte*)&val)+2) = *(((byte*)lpBytes)+0);
	*(((byte*)&val)+3) = 0;
	return val;
}

// NET -> UINT_32
inline unsigned int ntol(const void* lpBytes)					
{
	unsigned int val;	
	*(((byte*)&val)+0) = *(((byte*)lpBytes)+3);
	*(((byte*)&val)+1) = *(((byte*)lpBytes)+2);
	*(((byte*)&val)+2) = *(((byte*)lpBytes)+1);
	*(((byte*)&val)+3) = *(((byte*)lpBytes)+0);
	return val;
}

// NET -> ULONG_64
inline unsigned long long ntoll(const void* lpBytes)					
{
	unsigned long long val;	
	*(((byte*)&val)+0) = *(((byte*)lpBytes)+7);
	*(((byte*)&val)+1) = *(((byte*)lpBytes)+6);
	*(((byte*)&val)+2) = *(((byte*)lpBytes)+5);
	*(((byte*)&val)+3) = *(((byte*)lpBytes)+4);

	*(((byte*)&val)+4) = *(((byte*)lpBytes)+3);
	*(((byte*)&val)+5) = *(((byte*)lpBytes)+2);
	*(((byte*)&val)+6) = *(((byte*)lpBytes)+1);
	*(((byte*)&val)+7) = *(((byte*)lpBytes)+0);
	return val;
}

inline void encode_header(DIAM::MESSAGE_HEADER header, byte *buf, uint size)
{
	buf[0x00] = header.version;					//[x00 - x00] Version
	tton(size, &buf[0x01]);						//[x01 - x03] Message Length
	buf[0x04] = header.r_mask | header.t_mask;	//[x04 - x04] Command Flags
	tton(header.command_code,	&buf[0x05]);	//[x05 - x07] Command-Code
	lton(header.appl_id,	&buf[0x08]);		//[x08 - x0B] Application-ID
	lton(header.hop_by_hop,	&buf[0x0C]);		//[x0C - x0F] Hop-by-Hop-Identifier
	lton(header.end_to_end,	&buf[0x10]);		//[x10 - x13] End-to-End-Identifier
}

inline void encode_address(DIAM::AVP avp, in_addr addr, byte *buf, uint &index)		
{
	lton(avp, &buf[index]);
	index += 4;
	buf[index] = 64;
	index++;
	tton(14, &buf[index]);
	index += 3;
	byte IPV4_FMLY[2]= { 0x00, 0x01 };
	memcpy(&buf[index], &IPV4_FMLY[0], sizeof(IPV4_FMLY));
	index += sizeof(IPV4_FMLY);
	memcpy(&buf[index], &addr, sizeof(addr));
	index += sizeof(addr);
	for (uint i = 0; i < 2; i++)
		buf[index++] = 0;
}

inline void encode_address(DIAM::AVP avp, const char *u, byte *buf, uint &index, bool mandatory = true, uint vendor = 0)		
{
	in_addr addr;
	addr.s_addr = inet_addr(u);

	lton(avp, &buf[index]);
	index += 4;
	buf[index] = vendor ? 128 : 0 | mandatory ? 64 : 0;
	index++;
	tton(14 + (vendor ? 4 : 0), &buf[index]);
	index += 3;
	
	if (vendor)
	{
		lton(vendor, &buf[index]);
		index += 4;
	}

	byte IPV4_FMLY[2]= { 0x00, 0x01 };
	memcpy(&buf[index], &IPV4_FMLY[0], sizeof(IPV4_FMLY));
	index += sizeof(IPV4_FMLY);
	memcpy(&buf[index], &addr, sizeof(addr));
	index += sizeof(addr);
	for (uint i = 0; i < 2; i++)
		buf[index++] = 0;
}

inline void encode_time_zone(DIAM::AVP avp, int time_zone, int sign, int day_light_saving_time, byte *buf, uint &index, bool mandatory = true, uint vendor = 0)
{
		uint str_len = 0x04;
		uint pad_len = (4 - str_len % 4) % 4;

		if ((DIAM::AVP_HEADER_SIZE + str_len + pad_len + index) >= MAX_PACKET_SIZE)
			return;

		lton(avp, &buf[index]);
		index += 4;
		buf[index] = 128 | 0;
		index++;
		tton(str_len + pad_len + DIAM::AVP_HEADER_SIZE + 4, &buf[index]);
		index += 3;
		
		lton(vendor /*10415*/, &buf[index]);
		index += 4;

		buf[index++] = avp/*DIAM::MS_TimeZone*/;
		buf[index++] = 0x00;

		if (time_zone > 10)
		{
			int semioctet_0_3 = 0;
			int semioctet_4_7 = 0;

			semioctet_0_3 = time_zone / 10;
			semioctet_4_7 = time_zone % 10;
			if (semioctet_0_3 > 7)
			{
				semioctet_0_3--;
				semioctet_4_7 += 10;
			}

			buf[index] = semioctet_4_7 << 4 | semioctet_0_3;
		}
		else
		{
			buf[index] = time_zone << 4;
		}
		buf[index++] |= sign << 3;

		buf[index++] = day_light_saving_time;
//		encode_str(DIAM::MS_TimeZone, psInformation.Gpp3MsTimeZone.c_str(), buf, index, false, 10415);
}

inline void encode_str(DIAM::AVP avp, const char *u, byte *buf, uint &index, bool mandatory = true, uint vendor = 0)
{
	uint str_len = (uint)strlen(u);
	uint pad_len = (4 - str_len % 4) % 4;

	if ((DIAM::AVP_HEADER_SIZE + str_len + pad_len + index) >= MAX_PACKET_SIZE)
		return;

	lton(avp, &buf[index]);
	index += 4;
	buf[index] = vendor ? 128 : 0 | mandatory ? 64 : 0;
	index++;
	tton(str_len + DIAM::AVP_HEADER_SIZE + (vendor ? 4 : 0), &buf[index]);
	index += 3;
	
	if (vendor)
	{
		lton(vendor, &buf[index]);
		index += 4;
	}

	for (uint i = 0; i < str_len; i++)
		buf[index++] = u[i];
	for (uint i = 0; i < pad_len; i++)
		buf[index++] = 0;
}

inline void encode_octet(DIAM::AVP avp, const char *u, byte *buf, uint &index, bool mandatory = true, uint vendor = 0)
{
	uint str_len = 0x01;
	uint pad_len = (4 - str_len % 4) % 4;

	if ((DIAM::AVP_HEADER_SIZE + str_len + pad_len + index) >= MAX_PACKET_SIZE)
		return;

	lton(avp, &buf[index]);
	index += 4;
	buf[index] = vendor ? 128 : 0 | mandatory ? 64 : 0;
	index++;
	tton(str_len + DIAM::AVP_HEADER_SIZE + (vendor ? 4 : 0), &buf[index]);
	index += 3;
	
	if (vendor)
	{
		lton(vendor, &buf[index]);
		index += 4;
	}

	byte val[2];
	memset(val, 0, 2);
	int valLength = (int)strlen(u);;

	byte b;
	char* stopper;
	for (int i = valLength > 1 ? 0 : 1; i < 2; ++i)
	{
		if (i < valLength)
		{
			b = (byte)u[i];
			val[i] = (byte)strtol((char*)&b, &stopper, 16);
		}
	}

	buf[index++] = val[0] << 4 | val[1];
	for (uint i = 0; i < pad_len; i++)
		buf[index++] = 0;
}

inline void encode_uint32(DIAM::AVP avp, unsigned int u, byte *buf, uint &index, bool mandatory = true, uint vendor = 0)		
{
	if ((DIAM::AVP_HEADER_SIZE + 4) >= MAX_PACKET_SIZE)
		return;

	lton(avp, &buf[index]);
	index += 4;
	buf[index] = vendor ? 128 : 0 | mandatory ? 64 : 0;
	index++;
	tton(12 + (vendor ? 4 : 0), &buf[index]);
	index += 3;

	if (vendor)
	{
		lton(vendor, &buf[index]);
		index += 4;
	}

	lton(u, &buf[index]);
	index += 4;
}

inline void encode_bad_uint32(DIAM::AVP avp, unsigned int size, unsigned int u, byte *buf, uint &index)		
{
	lton(avp, &buf[index]);
	index += 4;
	buf[index] = 64;
	index++;
	tton(size, &buf[index]);
	index += 3;
	lton(u, &buf[index]);
	index += 4;
}

inline void encode_uint64(DIAM::AVP avp, ulong u, byte *buf, uint &index)		
{
	if ((DIAM::AVP_HEADER_SIZE + 8) >= MAX_PACKET_SIZE)
		return;

	lton(avp, &buf[index]);
	index += 4;
	buf[index] = 64;
	index++;
	tton(16, &buf[index]);
	index += 3;
	llton(u, &buf[index]);
	index += 8;
}

inline void encode_group(DIAM::AVP avp, std::list<SubscriptionId> subscription_id_list
						 , byte *buf
						 , uint &index)		
{
	std::list<SubscriptionId>::iterator it = subscription_id_list.begin();
	for (; it != subscription_id_list.end(); ++it)
	{
		uint h_ind = index;
		index += DIAM::AVP_HEADER_SIZE;

		encode_uint32(DIAM::Subscription_Id_Type, it->SubscriptionIdType, buf, index);
		encode_str(DIAM::Subscription_Id_Data, it->SubscriptionIdData.c_str(), buf, index);
		lton(avp, &buf[h_ind]);
		buf[h_ind + 4] = 64;
		tton(index - h_ind, &buf[h_ind + 5]);
	}
}

inline void encode_units(DIAM::AVP avp, DIAM::QUOTA_TYPE quota_type, ulong value, byte *buf, uint &index, uint currencyCode = 0)
{
	uint h_ind = index;
	index += DIAM::AVP_HEADER_SIZE;

	if (value)
	{
		switch (quota_type)
		{
		case DIAM::TIME:
			encode_uint32(DIAM::CC_Time, (uint)value, buf, index);
			break;
		case DIAM::INPUT_OCTETS:
			encode_uint64(DIAM::CC_Input_Octets, value, buf, index);
			break;
		case DIAM::OUTPUT_OCTETS:
			encode_uint64(DIAM::CC_Output_Octets, value, buf, index);
			break;	
		case DIAM::TOTAL_OCTETS:
			encode_uint64(DIAM::CC_Total_Octets, value, buf, index);
			break;	
		case DIAM::SERVICE_SPECIFIC_UNITS:
			encode_uint64(DIAM::CC_Units, value, buf, index);
			break;	
		case DIAM::MONEY:
			{// encode CC-Money
				uint h_ind = index;
				index += DIAM::AVP_HEADER_SIZE;

				{// encode Unit-Value
					uint h_ind = index;
					index += DIAM::AVP_HEADER_SIZE;
					// encode Value-Digits
					encode_uint64((DIAM::AVP)447, value, buf, index);
					// encode Exponent
					encode_uint32((DIAM::AVP)429, (uint)-2, buf, index);

					lton((DIAM::AVP)445, &buf[h_ind]);
					buf[h_ind + 4] = 64;
					tton(index - h_ind, &buf[h_ind + 5]);
				}
				// encode Currency-Code
				encode_uint32((DIAM::AVP)425, currencyCode, buf, index);

				lton(DIAM::CC_Money, &buf[h_ind]);
				buf[h_ind + 4] = 64;
				tton(index - h_ind, &buf[h_ind + 5]);
			}
			break;	
		}
	}
	lton(avp, &buf[h_ind]);
	buf[h_ind + 4] = 0;
	tton(index - h_ind, &buf[h_ind + 5]);
}

inline void encode_group(DIAM::AVP avp, MultipleServiceMap mscc_list, byte *buf, uint &index, uint currencyCode, uint message_type)		
{
	MultipleServiceMap::iterator it = mscc_list.begin();
	for (; it != mscc_list.end(); ++it)
	{
		if (it->second.Completed) continue;

		uint h_ind = index;
		index += DIAM::AVP_HEADER_SIZE;

		if (it->second.VolumeLastUsed)
		{
			encode_units(DIAM::Used_Service_Unit, it->second.QuotaType, it->second.VolumeLastUsed, buf, index, currencyCode);
		}
		if (it->second.VolumeToUse)
		{
			encode_units(DIAM::Requested_Service_Unit, it->second.QuotaType, it->second.ExternalQuoting ? it->second.QuotaSize : 0, buf, index, currencyCode);
		}

		if (it->first.first != (uint)-1)
			encode_uint32(DIAM::Rating_Group, it->first.first, buf, index);
		if (it->first.second != (uint)-1)
			encode_uint32(DIAM::Service_Identifier, it->first.second, buf, index);
		if (!it->second.UserData.empty())
			encode_str(DIAM::User_Data, it->second.UserData.c_str(), buf, index, false, 11971);

		//if (mscc->reporting_reason)
		//{
		//	encode_uint32(DIAM::Reporting_Reason, mscc->reporting_reason, buf, index);
		//}

		if( message_type ==  40 /*MSG_CCR_READY*/ || message_type == 42 /*MSG_CCR_TERMINATE_READY*/ )
		{
			// Service-Specific-Info
			if( !it->second.SpecificData.empty() || it->second.SpecificType > 0 ) {
				uint h_ind_ssi = index;
				index += DIAM::AVP_HEADER_SIZE + 4;

				if( it->second.SpecificType > 0 )
					encode_uint32(DIAM::Service_Specific_Type, it->second.SpecificType , buf, index, true, 10415);

				if( !it->second.SpecificData.empty() )
					encode_str(DIAM::Service_Specific_Data, it->second.SpecificData.c_str(), buf, index, true, 10415);

				lton(DIAM::Service_Specific_Info, &buf[h_ind_ssi]);
				buf[h_ind_ssi + 4] = 192;
				tton(index - h_ind_ssi, &buf[h_ind_ssi + 5]);
				lton(10415, &buf[h_ind_ssi + 8]);
			}
		}

		
		lton(avp, &buf[h_ind]);
		buf[h_ind + 4] = 0;
		tton(index - h_ind, &buf[h_ind + 5]);
	}
}


inline void encode_group(DIAM::AVP avp, MultipleService* service, byte *buf, uint &index, uint currencyCode = 0)
{
	uint h_ind = index;
	index += DIAM::AVP_HEADER_SIZE;
	switch (service->QuotaType)
	{
	case DIAM::TIME:
		encode_uint32(DIAM::CC_Time, (uint)service->Volume, buf, index);
		break;
	case DIAM::INPUT_OCTETS:
		encode_uint64(DIAM::CC_Input_Octets, service->Volume, buf, index);
		break;
	case DIAM::OUTPUT_OCTETS:
		encode_uint64(DIAM::CC_Output_Octets, service->Volume, buf, index);
		break;	
	case DIAM::TOTAL_OCTETS:
		encode_uint64(DIAM::CC_Total_Octets, service->Volume, buf, index);
		break;	
	case DIAM::SERVICE_SPECIFIC_UNITS:
		encode_uint64(DIAM::CC_Units, service->Volume, buf, index);
		break;	
	case DIAM::MONEY:
		{// encode CC-Money
			uint h_ind = index;
			index += DIAM::AVP_HEADER_SIZE;

			{// encode Unit-Value
				uint h_ind = index;
				index += DIAM::AVP_HEADER_SIZE;
				// encode Value-Digits
				encode_uint64((DIAM::AVP)447, service->Volume, buf, index);
				// encode Exponent
				encode_uint32((DIAM::AVP)429, (uint)-2, buf, index);

				lton((DIAM::AVP)445, &buf[h_ind]);
				buf[h_ind + 4] = 64;
				tton(index - h_ind, &buf[h_ind + 5]);
			}
			// encode Currency-Code
			encode_uint32((DIAM::AVP)425, currencyCode, buf, index);

			lton(DIAM::CC_Money, &buf[h_ind]);
			buf[h_ind + 4] = 64;
			tton(index - h_ind, &buf[h_ind + 5]);
		}
		break;	
	}
	lton(avp, &buf[h_ind]);
	buf[h_ind + 4] = 0;
	tton(index - h_ind, &buf[h_ind + 5]);
}

inline void encode_group(DIAM::AVP avp, GPP3PSInformation &psInformation, byte *buf, uint &index)		
{
	uint h_ind = index;
	index += (DIAM::AVP_HEADER_SIZE + 4);

	if (!psInformation.Gpp3ChargingId.empty())
		encode_str(DIAM::GPP3_Charging_id, psInformation.Gpp3ChargingId.c_str(), buf, index, false, 10415);
	if (psInformation.Gpp3PdpType >= 0)
		encode_uint32(DIAM::GPP3_PDP_Type, psInformation.Gpp3PdpType, buf, index, false, 10415);
	if (!psInformation.PdpAddress.empty())
		encode_address(DIAM::PDP_Address, psInformation.PdpAddress.c_str(), buf, index, false, 10415);
	if (!psInformation.SgsnAddress.empty())
		encode_address(DIAM::SGSN_Address, psInformation.SgsnAddress.c_str(), buf, index, false, 10415);
	if (!psInformation.GgsnAddress.empty())
		encode_address(DIAM::GGSN_Address, psInformation.GgsnAddress.c_str(), buf, index, false, 10415);
	if (!psInformation.Gpp3Nsapi.empty())
		encode_str(DIAM::GPP3_NSAPI, psInformation.Gpp3Nsapi.c_str(), buf, index, false, 10415);
	if (!psInformation.CalledStationId.empty())
		encode_str(DIAM::Called_Station_Id, psInformation.CalledStationId.c_str(), buf, index, false);
	if (!psInformation.Gpp3SelectionMode.empty())
		encode_str(DIAM::GPP3_Selection_mode, psInformation.Gpp3SelectionMode.c_str(), buf, index, false, 10415);
	if (!psInformation.Gpp3ChargingCharacteristics.empty())
		encode_str(DIAM::GPP3_Charging_Characteristics, psInformation.Gpp3ChargingCharacteristics.c_str(), buf, index, false, 10415);
	if (psInformation.Gpp3MsTimeZonePresent)
		encode_time_zone(DIAM::MS_TimeZone, psInformation.TimeZone, psInformation.Sign, psInformation.DaylightSavingTime, buf, index, true, 10415);

	if (!psInformation.ChagingRuleBaseName.empty())
		encode_str(DIAM::Charging_Rule_Base_Name, psInformation.ChagingRuleBaseName.c_str(), buf, index, false, 10415);

	if (!psInformation.Gpp3ImsiMccMnc.empty())
		encode_str(DIAM::GPP3_IMSI_MCC_MNC, psInformation.Gpp3ImsiMccMnc.c_str(), buf, index, false, 10415);

	if (!psInformation.Gpp3SgsnMccMnc.empty())
		encode_str(DIAM::GPP3_SGSN_MCC_MNC, psInformation.Gpp3SgsnMccMnc.c_str(), buf, index, false, 10415);

	if (!psInformation.Gpp3GprsNegotiatedQosProfile.empty())
		encode_str(DIAM::GPP3_GPRS_NEGOTIATED_QOS_PROFILE, psInformation.Gpp3GprsNegotiatedQosProfile.c_str(), buf, index, false, 10415);

	if (psInformation.Gpp3UserLocationInfoPresent)
	{
		uint str_len = 0x07;
		uint pad_len = (4 - str_len % 4) % 4;

		if ((DIAM::AVP_HEADER_SIZE + str_len + pad_len + index) >= MAX_PACKET_SIZE)
			return;

		lton(DIAM::User_Location_Info, &buf[index]);
		index += 4;
		buf[index] = 128 | 0;
		index++;
		tton(str_len + pad_len + DIAM::AVP_HEADER_SIZE + 4, &buf[index]);
		index += 3;
		
		lton(10415, &buf[index]);
		index += 4;

		//filler
		buf[index++] = 0x00;
		
		//mcc
		//mnc
		byte mcc[3];
		byte mnc[3];
		memset(mcc, 0xF, 3);
		memset(mnc, 0xF, 3);
		int mccLength = (int)psInformation.Mcc.length();
		int mncLength = (int)psInformation.Mnc.length();
		char* mccValue = (char*)psInformation.Mcc.c_str();
		char* mncValue = (char*)psInformation.Mnc.c_str();

		byte b;
		for (int i = 0; i < 3; ++i)
		{
			if (i < mccLength)
			{
				b = (byte)mccValue[i];
				mcc[i] = atoi((char*)&b);
			}
			if (i < mncLength)
			{
				b = (byte)mncValue[i];
				mnc[i] = atoi((char*)&b);
			}
		}

		buf[index++] = mcc[0] | mcc[1] << 4;
		buf[index++] = mcc[2] | mnc[2] << 4;
		buf[index++] = mnc[0] | mnc[1] << 4;
		//a_area
		ston(psInformation.Area, &buf[index]);
		index += 2;
		//a_cell
		ston(psInformation.Cell, &buf[index]);
		index += 2;

		//for (uint i = 0; i < pad_len; i++)
		//	buf[index++] = 0;

		//encode_str(DIAM::User_Location_Info, psInformation.Gpp3UserLocationInfo.c_str(), buf, index, false, 10415);
	}
	lton(avp, &buf[h_ind]);
	buf[h_ind + 4] = 192;
	lton(10415, &buf[h_ind + 8]);
	tton(index - h_ind, &buf[h_ind + 5]);
}

inline void encode_group(DIAM::AVP avp, GPP3MMSInformation &mmsInformation, byte *buf, uint &index)		
{
	uint h_ind = index;
	index += (DIAM::AVP_HEADER_SIZE + 4);

	if (!mmsInformation.RecipientAddress.empty())
		encode_str(DIAM::Recipient_Address, mmsInformation.RecipientAddress.c_str(), buf, index, false, 10415);
	lton(avp, &buf[h_ind]);
	buf[h_ind + 4] = 192;
	lton(10415, &buf[h_ind + 8]);
	tton(index - h_ind, &buf[h_ind + 5]);
}

inline void encode_group(DIAM::AVP avp, ServiceParameterInfo &spInformation, byte *buf, uint &index)
{
	if( spInformation.Present ) {
		uint h_ind = index;
		index += DIAM::AVP_HEADER_SIZE;

		if( spInformation.ServiceParameterType > 0 )
			encode_uint32(DIAM::Service_Parameter_Type, (uint)spInformation.ServiceParameterType, buf, index);		

		if( !spInformation.ServiceParameterValue.empty() )
			encode_str(DIAM::Service_Parameter_Value, spInformation.ServiceParameterValue.c_str(), buf, index);

		lton(avp, &buf[h_ind]);
		buf[h_ind + 4] = 0;
		tton(index - h_ind, &buf[h_ind + 5]);
	}
}

inline void encode_group(DIAM::AVP avp, UserEquipmentInfo &ueInformation, byte *buf, uint &index)
{
	if( ueInformation.Present ) {
		uint h_ind = index;
		index += DIAM::AVP_HEADER_SIZE;

		if( ueInformation.UserEquipmentInfoType >= 0 )
			encode_uint32(DIAM::User_Equipment_Info_Type, (uint)ueInformation.UserEquipmentInfoType, buf, index);

		if( !ueInformation.UserEquipmentInfoValue.empty() )
			encode_str(DIAM::User_Equipment_Info_Value, ueInformation.UserEquipmentInfoValue.c_str(), buf, index);

		lton(avp, &buf[h_ind]);
		buf[h_ind + 4] = 0;
		tton(index - h_ind, &buf[h_ind + 5]);
	}
}

inline void encode_group(DIAM::AVP avp, ServiceVoiceInformation &svInformation, byte *buf, uint &index)
{
	if( svInformation.Present )
	{
		uint h_ind = index;
		index += DIAM::AVP_HEADER_SIZE + 4;

		if ( svInformation.ATimeZonePresent )
			encode_time_zone(DIAM::ATime_Zone, svInformation.ATimeZone, svInformation.ASign, svInformation.ADaylightSavingTime, buf, index, true, 11971);

		if (!svInformation.AMCC.empty())
			encode_str(DIAM::AMCC, svInformation.AMCC.c_str(), buf, index, false, 11971);

		if (!svInformation.AMNC.empty())
			encode_str(DIAM::AMNC, svInformation.AMNC.c_str(), buf, index, false, 11971);

		if (svInformation.AArea >= 0)
			encode_uint32(DIAM::AArea, svInformation.AArea, buf, index, false, 11971);

		if (svInformation.ACell >= 0)
			encode_uint32(DIAM::ACell, svInformation.ACell, buf, index, false, 11971);

		if( svInformation.ARoaming >= 0)
			encode_uint32(DIAM::ARoaming, svInformation.ARoaming, buf, index, true, 11971);

		if (!svInformation.AGlobalTitle.empty())
			encode_str(DIAM::AGlobal_Title, svInformation.AGlobalTitle.c_str(), buf, index, true, 11971);

		// Subscription-B
		if( svInformation.SubscriptionBIdType >= 0 || !svInformation.SubscriptionBIdData.empty() ) {
			uint h_ind_subsb = index;
			index += DIAM::AVP_HEADER_SIZE + 4;

			if( svInformation.SubscriptionBIdType >= 0 )
				encode_uint32(DIAM::Subscription_Id_Type, svInformation.SubscriptionBIdType, buf, index, true);

			if( !svInformation.SubscriptionBIdData.empty() )
				encode_str(DIAM::Subscription_Id_Data, svInformation.SubscriptionBIdData.c_str(), buf, index, true);

			lton(DIAM::SubscriptionB , &buf[h_ind_subsb]);
			buf[h_ind_subsb + 4] = 192;
			tton(index - h_ind_subsb, &buf[h_ind_subsb + 5]);
			lton(11971, &buf[h_ind_subsb + 8]);
		}

		if ( svInformation.BTimeZonePresent )
			encode_time_zone(DIAM::BTime_Zone, svInformation.BTimeZone, svInformation.BSign, svInformation.BDaylightSavingTime, buf, index, true, 11971);

		if( svInformation.SubscriptionCIdType > 0 || !svInformation.SubscriptionCIdData.empty() )
		{
			// Subscription-C
			uint h_ind_subsc = index;
			index += DIAM::AVP_HEADER_SIZE + 4;

			if( svInformation.SubscriptionCIdType >= 0 )
				encode_uint32(DIAM::Subscription_Id_Type, svInformation.SubscriptionCIdType, buf, index, true);

			if( !svInformation.SubscriptionCIdData.empty() )
				encode_str(DIAM::Subscription_Id_Data, svInformation.SubscriptionCIdData.c_str(), buf, index, true);

			lton(DIAM::SubscriptionC , &buf[h_ind_subsc]);
			buf[h_ind_subsc + 4] = 192;
			tton(index - h_ind_subsc, &buf[h_ind_subsc + 5]);
			lton(11971, &buf[h_ind_subsc + 8]);
		}		

		lton(avp, &buf[h_ind]);
		buf[h_ind + 4] = 192;
		tton(index - h_ind, &buf[h_ind + 5]);
		lton(11971, &buf[h_ind + 8]);
	}
}

static time_t GetDateTimeFromString(const char* stime)
{
	tm		time;
	time_t	res;
	try
	{
		// перекодируем строку даты в time_t
		__int64 lTime = _atoi64(stime);
		time.tm_year	= (int)(lTime / 10000000000L) - 1900;
		time.tm_mon		= (int)(lTime % 10000000000L)/(100000000L) - 1;
		time.tm_mday	= (int)(lTime % 100000000L)/1000000L;
		time.tm_hour	= (int)(lTime % 1000000L)/(10000L);
		time.tm_min		= (int)(lTime % 10000L)/100L;
		time.tm_sec		= (int)(lTime % 100L);

		res = mktime(&time) - _timezone;
	}
	catch(...)
	{
	}
	return res;
}

inline void encode_group(DIAM::AVP avp, GPP3SMSInformation &smsInformation, GPP3PSInformation &psInformation, byte *buf, uint &index)		
{
	uint h_ind = index;
	index += (DIAM::AVP_HEADER_SIZE + 4);

	if (smsInformation.RootFieldsPresent)
	{
		if (smsInformation.SmsNode >= 0)
			encode_uint32(DIAM::SMS_Node, smsInformation.SmsNode, buf, index, false, 10415);
		if (!smsInformation.ClientAddress.empty())
			encode_address(DIAM::Client_Address, smsInformation.ClientAddress.c_str(), buf, index, false, 10415);
		if (!smsInformation.OriginatorSccpAddress.empty())
			encode_str(DIAM::Originator_SCCP_Address, smsInformation.OriginatorSccpAddress.c_str(), buf, index, false, 10415);
		if (!smsInformation.SmscAddress.empty())
			encode_address(DIAM::SMSC_Address, smsInformation.SmscAddress.c_str(), buf, index, false, 10415);
		if (smsInformation.DataCodingScheme >= 0)
			encode_uint32(DIAM::Data_Coding_Scheme, smsInformation.DataCodingScheme, buf, index, false, 10415);
		if (!smsInformation.SmDischargeTime.empty())
		{
			uint t = (uint)GetDateTimeFromString(smsInformation.SmDischargeTime.c_str()) + delta_1970_1900;
			encode_uint32(DIAM::SM_Discharge_Time, t, buf, index, false, 10415);
		}
		if (smsInformation.SmMessageType >= 0)
			encode_uint32(DIAM::SM_Message_Type, smsInformation.SmMessageType, buf, index, false, 10415);
		//Originator-Interface
		//TBD
		if (!smsInformation.SmProtocolId.empty())
			encode_octet(DIAM::SM_Protocol_Id, smsInformation.SmProtocolId.c_str(), buf, index, false, 10415);
		if (smsInformation.ReplyPathRequested >= 0)
			encode_uint32(DIAM::Reply_Path_Requested, smsInformation.ReplyPathRequested, buf, index, false, 10415);
		if (!smsInformation.SmStatus.empty())
			encode_octet(DIAM::SM_Status, smsInformation.SmStatus.c_str(), buf, index, false, 10415);
		if (!smsInformation.SmUserDataHeader.empty())
			encode_octet(DIAM::SM_User_Data_Header, smsInformation.SmUserDataHeader.c_str(), buf, index, false, 10415);
		if (smsInformation.NumberOfMessagesSent != -1)
			encode_uint32(DIAM::Number_Of_Messages_Sent, smsInformation.NumberOfMessagesSent, buf, index, false, 10415);
		//Recipient-Info
		//TBD
		//Originator-Received-Address
		//TBD
		if (smsInformation.SmServiceType >= 0)
			encode_uint32(DIAM::SM_Service_Type, smsInformation.SmServiceType, buf, index, false, 10415);
	}

	if (smsInformation.OriginatorInterfacePresent)
	{
		uint h_ind = index;
		index += (DIAM::AVP_HEADER_SIZE + 4);

		if (!smsInformation.InterfaceId.empty())
			encode_str(DIAM::Interface_Id, smsInformation.InterfaceId.c_str(), buf, index, false, 10415);
		if (!smsInformation.InterfacePort.empty())
			encode_str(DIAM::Interface_Port, smsInformation.InterfacePort.c_str(), buf, index, false, 10415);
		if (!smsInformation.InterfaceText.empty())
			encode_str(DIAM::Interface_Text, smsInformation.InterfaceText.c_str(), buf, index, false, 10415);
		if (smsInformation.OriginatorInterfaceType >= 0)
			encode_uint32(DIAM::Interface_Type, smsInformation.OriginatorInterfaceType, buf, index, false, 10415);

		lton(DIAM::Originator_Interface, &buf[h_ind]);
		buf[h_ind + 4] = 192;
		lton(10415, &buf[h_ind + 8]);
		tton(index - h_ind, &buf[h_ind + 5]);
	}

	if (smsInformation.RecipientInfoPresent)
	{
		uint h_ind = index;
		index += (DIAM::AVP_HEADER_SIZE + 4);

		if (smsInformation.DestinationInterfacePresent)
		{
			uint h_ind = index;
			index += (DIAM::AVP_HEADER_SIZE + 4);

			if (!smsInformation.DestinationInterfaceId.empty())
				encode_str(DIAM::Interface_Id, smsInformation.DestinationInterfaceId.c_str(), buf, index, false, 10415);
			if (!smsInformation.DestinationInterfacePort.empty())
				encode_str(DIAM::Interface_Port, smsInformation.DestinationInterfacePort.c_str(), buf, index, false, 10415);
			if (!smsInformation.DestinationInterfaceText.empty())
				encode_str(DIAM::Interface_Text, smsInformation.DestinationInterfaceText.c_str(), buf, index, false, 10415);
			if (smsInformation.DestinationInterfaceType >= 0)
				encode_uint32(DIAM::Interface_Type, smsInformation.DestinationInterfaceType, buf, index, false, 10415);

			lton(DIAM::Destination_Interface, &buf[h_ind]);
			buf[h_ind + 4] = 192;
			lton(10415, &buf[h_ind + 8]);
			tton(index - h_ind, &buf[h_ind + 5]);
		}

		if (smsInformation.RecipientAddressPresent)
		{
			uint h_ind = index;
			index += (DIAM::AVP_HEADER_SIZE + 4);

			if (!smsInformation.RecipientAddressData.empty())
				encode_str(DIAM::Address_Data, smsInformation.RecipientAddressData.c_str(), buf, index, false, 10415);
			if (!smsInformation.RecipientAddressDomainName.empty() || !smsInformation.RecipientAddressGpp3ImsiMccMnc.empty())
			{
				uint h_ind = index;
				index += (DIAM::AVP_HEADER_SIZE + 4);

				if (!smsInformation.RecipientAddressDomainName.empty())
					encode_str(DIAM::Domain_Name, smsInformation.RecipientAddressDomainName.c_str(), buf, index, false, 10415);
				if (!smsInformation.RecipientAddressGpp3ImsiMccMnc.empty())
					encode_str(DIAM::GPP3_IMSI_MCC_MNC, smsInformation.RecipientAddressGpp3ImsiMccMnc.c_str(), buf, index, false, 10415);

				lton(DIAM::Address_Domain, &buf[h_ind]);
				buf[h_ind + 4] = 192;
				lton(10415, &buf[h_ind + 8]);
				tton(index - h_ind, &buf[h_ind + 5]);
			}
			if (smsInformation.RecipientAddressType >= 0)
				encode_uint32(DIAM::Address_Type, smsInformation.RecipientAddressType, buf, index, false, 10415);
			if (smsInformation.RecipientAddresseeType >= 0)
				encode_uint32(DIAM::Addressee_Type, smsInformation.RecipientAddresseeType, buf, index, false, 10415);

			lton(DIAM::Recipient_Address, &buf[h_ind]);
			buf[h_ind + 4] = 192;
			lton(10415, &buf[h_ind + 8]);
			tton(index - h_ind, &buf[h_ind + 5]);
		}

		if (smsInformation.RecipientReceivedAddressPresent)
		{
			uint h_ind = index;
			index += (DIAM::AVP_HEADER_SIZE + 4);

			if (!smsInformation.RecipientReceivedAddressData.empty())
				encode_str(DIAM::Address_Data, smsInformation.RecipientReceivedAddressData.c_str(), buf, index, false, 10415);
			if (!smsInformation.RecipientReceivedAddressDomainName.empty() || !smsInformation.RecipientReceivedAddressGpp3ImsiMccMnc.empty())
			{
				uint h_ind = index;
				index += (DIAM::AVP_HEADER_SIZE + 4);

				if (!smsInformation.RecipientReceivedAddressDomainName.empty())
					encode_str(DIAM::Domain_Name, smsInformation.RecipientReceivedAddressDomainName.c_str(), buf, index, false, 10415);
				if (!smsInformation.RecipientReceivedAddressGpp3ImsiMccMnc.empty())
					encode_str(DIAM::GPP3_IMSI_MCC_MNC, smsInformation.RecipientReceivedAddressGpp3ImsiMccMnc.c_str(), buf, index, false, 10415);

				lton(DIAM::Address_Domain, &buf[h_ind]);
				buf[h_ind + 4] = 192;
				lton(10415, &buf[h_ind + 8]);
				tton(index - h_ind, &buf[h_ind + 5]);
			}
			if (smsInformation.RecipientReceivedAddressType >= 0)
				encode_uint32(DIAM::Address_Type, smsInformation.RecipientReceivedAddressType, buf, index, false, 10415);

			lton(DIAM::Recipient_Received_Address, &buf[h_ind]);
			buf[h_ind + 4] = 192;
			lton(10415, &buf[h_ind + 8]);
			tton(index - h_ind, &buf[h_ind + 5]);
		}

		if (!smsInformation.RecipientSccpAddress.empty())
			encode_str(DIAM::Recipient_SCCP_Address, smsInformation.RecipientSccpAddress.c_str(), buf, index, false, 10415);
	    
		if (!smsInformation.RecipientSmProtocolId.empty())
			encode_octet(DIAM::SM_Protocol_Id, smsInformation.RecipientSmProtocolId.c_str(), buf, index, false, 10415);

		lton(DIAM::Recipient_Info, &buf[h_ind]);
		buf[h_ind + 4] = 192;
		lton(10415, &buf[h_ind + 8]);
		tton(index - h_ind, &buf[h_ind + 5]);
	}

	if (smsInformation.OriginatorReceivedAddressPresent)
	{
		uint h_ind = index;
		index += (DIAM::AVP_HEADER_SIZE + 4);

		if (!smsInformation.AddressData.empty())
			encode_str(DIAM::Address_Data, smsInformation.AddressData.c_str(), buf, index, false, 10415);
		if (!smsInformation.DomainName.empty() || !smsInformation.Gpp3ImsiMccMnc.empty())
		{
			uint h_ind = index;
			index += (DIAM::AVP_HEADER_SIZE + 4);

			if (!smsInformation.DomainName.empty())
				encode_str(DIAM::Domain_Name, smsInformation.DomainName.c_str(), buf, index, false, 10415);
			if (!smsInformation.Gpp3ImsiMccMnc.empty())
				encode_str(DIAM::GPP3_IMSI_MCC_MNC, smsInformation.Gpp3ImsiMccMnc.c_str(), buf, index, false, 10415);

			lton(DIAM::Address_Domain, &buf[h_ind]);
			buf[h_ind + 4] = 192;
			lton(10415, &buf[h_ind + 8]);
			tton(index - h_ind, &buf[h_ind + 5]);
		}
		if (smsInformation.AddressType >= 0)
			encode_uint32(DIAM::Address_Type, smsInformation.AddressType, buf, index, false, 10415);

		lton(DIAM::Originator_Received_Address, &buf[h_ind]);
		buf[h_ind + 4] = 192;
		lton(10415, &buf[h_ind + 8]);
		tton(index - h_ind, &buf[h_ind + 5]);
	}

	if (psInformation.Gpp3MsTimeZonePresent)
	{
		uint str_len = 0x04;
		uint pad_len = (4 - str_len % 4) % 4;

		if ((DIAM::AVP_HEADER_SIZE + str_len + pad_len + index) >= MAX_PACKET_SIZE)
			return;

		lton(DIAM::MS_TimeZone, &buf[index]);
		index += 4;
		buf[index] = 128 | 0;
		index++;
		tton(str_len + pad_len + DIAM::AVP_HEADER_SIZE + 4, &buf[index]);
		index += 3;
		
		lton(10415, &buf[index]);
		index += 4;

		buf[index++] = DIAM::MS_TimeZone;
		buf[index++] = 0x00;

		if (psInformation.TimeZone > 10)
		{
			int semioctet_0_3 = 0;
			int semioctet_4_7 = 0;

			semioctet_0_3 = psInformation.TimeZone / 10;
			semioctet_4_7 = psInformation.TimeZone % 10;
			if (semioctet_0_3 > 7)
			{
				semioctet_0_3--;
				semioctet_4_7 += 10;
			}

			buf[index] = semioctet_4_7 << 4 | semioctet_0_3;
		}
		else
		{
			buf[index] = psInformation.TimeZone << 4;
		}
		buf[index++] |= psInformation.Sign << 3;

		buf[index++] = psInformation.DaylightSavingTime;
	}

	if (psInformation.Gpp3UserLocationInfoPresent)
	{
		uint str_len = 0x07;
		uint pad_len = (4 - str_len % 4) % 4;

		if ((DIAM::AVP_HEADER_SIZE + str_len + pad_len + index) >= MAX_PACKET_SIZE)
			return;

		lton(DIAM::User_Location_Info, &buf[index]);
		index += 4;
		buf[index] = 128 | 0;
		index++;
		tton(str_len + pad_len + DIAM::AVP_HEADER_SIZE + 4, &buf[index]);
		index += 3;
		
		lton(10415, &buf[index]);
		index += 4;

		//filler
		buf[index++] = 0x00;
		
		//mcc
		//mnc
		byte mcc[3];
		byte mnc[3];
		memset(mcc, 0xF, 3);
		memset(mnc, 0xF, 3);
		int mccLength = (int)psInformation.Mcc.length();
		int mncLength = (int)psInformation.Mnc.length();
		char* mccValue = (char*)psInformation.Mcc.c_str();
		char* mncValue = (char*)psInformation.Mnc.c_str();

		byte b;
		for (int i = 0; i < 3; ++i)
		{
			if (i < mccLength)
			{
				b = (byte)mccValue[i];
				mcc[i] = atoi((char*)&b);
			}
			if (i < mncLength)
			{
				b = (byte)mncValue[i];
				mnc[i] = atoi((char*)&b);
			}
		}

		buf[index++] = mcc[0] | mcc[1] << 4;
		buf[index++] = mcc[2] | mnc[2] << 4;
		buf[index++] = mnc[0] | mnc[1] << 4;
		//a_area
		ston(psInformation.Area, &buf[index]);
		index += 2;
		//a_cell
		ston(psInformation.Cell, &buf[index]);
		index += 2;

	}
	lton(avp, &buf[h_ind]);
	buf[h_ind + 4] = 192;
	lton(10415, &buf[h_ind + 8]);
	tton(index - h_ind, &buf[h_ind + 5]);
}

inline void encode_group(DIAM::AVP avp, GPP3PSInformation &psInformation, GPP3MMSInformation &mmsInformation, GPP3SMSInformation &smsInformation, byte *buf, uint &index)		
{
	if (psInformation.Present || mmsInformation.Present || smsInformation.Present)
	{
		uint h_ind = index;
		index += (DIAM::AVP_HEADER_SIZE + 4);

		if (psInformation.Present)
		{
			encode_group(DIAM::PS_Information, psInformation, buf, index);
		}

		if (mmsInformation.Present)
		{
			encode_group(DIAM::MMS_Information, mmsInformation, buf, index);
		}

		if (smsInformation.Present)
		{
			encode_group(DIAM::SMS_Information, smsInformation, psInformation, buf, index);
		}

		lton(avp, &buf[h_ind]);
		buf[h_ind + 4] = 192;
		lton(10415, &buf[h_ind + 8]);
		tton(index - h_ind, &buf[h_ind + 5]);
	}
}

inline void decode_str(byte *buf, std::string &str, uint size, uint &index)
{
	uint str_len = size - DIAM::AVP_HEADER_SIZE;
	for (uint i = 0; i < str_len; i++)
		str += buf[index++];

	uint pad_len = (4 - str_len % 4) % 4;
	index += pad_len;
}

inline uint decode_uint32(byte *buf, uint &index)
{
	uint val = ntol(&buf[index]);
	index += 4;

	return val;
}

inline ulong decode_uint64(byte *buf, uint &index)
{
	ulong val = (ulong)ntoll(&buf[index]);
	index += 8;

	return val;
}

inline in_addr decode_address(byte *buf, uint &index)
{
	in_addr addr;
	memcpy(&addr, &buf[index] + 2, sizeof(addr));
	index += sizeof(addr) + 4;
	return addr;
}

inline ulong decode_money(byte *buf, uint &index, uint length)
{
	ulong value = (ulong)-1;
	
	uint startIndex = index - DIAM::AVP_HEADER_SIZE;
	do
	{
		DIAM::AVP_HEADER subMoneyHeader(buf, index);
		switch (subMoneyHeader.avp_code)
		{
		case DIAM::Currency_Code:
			decode_uint32(buf, index);
			break;
		case DIAM::Unit_Value:
			{
				uint startIndex = index - DIAM::AVP_HEADER_SIZE;
				int		exp = 2;
				ulong	digits = 0;

				do
				{
					DIAM::AVP_HEADER subUnitValueHeader(buf, index);
					switch (subUnitValueHeader.avp_code)
					{
					case DIAM::Value_Digits:
						digits = decode_uint64(buf, index);;
						break;
					case DIAM::Exponent:
						exp += decode_uint32(buf, index);
						break;
					}
				}
				while (index - startIndex < subMoneyHeader.avp_length);
				value = (ulong)ceil(digits * pow((double)10, exp));
			}
			break;
		}
	}
	while (index - startIndex < length);
	
	return value;
}


inline ulong decode_units(byte *buf, uint &index, uint length)
{
	ulong value = (ulong)-1;

	uint startIndex = index - DIAM::AVP_HEADER_SIZE;
	do
	{
		DIAM::AVP_HEADER subUnitsHeader(buf, index);
		switch (subUnitsHeader.avp_code)
		{
		case DIAM::CC_Time:
			value = decode_uint32(buf, index);
			break;
		case DIAM::CC_Input_Octets:
			value = decode_uint64(buf, index);
			break;
		case DIAM::CC_Output_Octets:
			value = decode_uint64(buf, index);
			break;
		case DIAM::CC_Total_Octets:
			value = decode_uint64(buf, index);
			break;
		case DIAM::CC_Units:
			value = decode_uint64(buf, index);
			break;
		case DIAM::CC_Money:
			value = decode_money(buf, index, subUnitsHeader.avp_length);
			break;
		default:
			index += (subUnitsHeader.avp_length + ((4 - (subUnitsHeader.avp_length % 4)) % 4) - DIAM::AVP_HEADER_SIZE);
			break;
		}
	}
	while (index - startIndex < length);

	return value;
}

inline void decode_account_information(byte *buf, uint &index, uint length, int& account_type, int& service_content_type)
{
	uint startIndex = index - DIAM::AVP_HEADER_SIZE - 4;
	do
	{
		DIAM::AVP_HEADER subAccountInformationHeader(buf, index);
		switch (subAccountInformationHeader.avp_code)
		{
			case DIAM::Account_Type:
				account_type = decode_uint32(buf, index);
				break;
			case DIAM::Service_Content_Type:
				service_content_type = decode_uint32(buf, index);
				break;
		
		}
	}
	while (index - startIndex < length);
}

inline size_t ASCIItoUNICODE(char* dst, unsigned char* src, size_t n)
{
	memset(dst, 0, n);
	size_t ret = 0;
	while(*src)
	{
		unsigned char ch = *src++;

		if (ch == 168)
		{
			if (ret + 2 > n) break;

			dst[ret++] = (char)208;
			dst[ret++] = (char)129;
		}
		else if (ch == 184)
		{
			if (ret + 2 > n) break;

			dst[ret++] = (char)209;
			dst[ret++] = (char)145;
		}
		else if (ch < 192)
		{
			if (ret + 1 > n) break;

			dst[ret++] = (char)ch;
		}
		else if (ch < 240)
		{
			if (ret + 2 > n) break;

			dst[ret++] = (char)208;
			dst[ret++] = (char)(ch - 48);
		}
		else if (ch < 256)
		{
			if (ret + 2 > n) break;

			dst[ret++] = (char)209;
			dst[ret++] = (char)(ch - 112);
		}
	}
	if (ret < n) dst[ret++] = (char)0;
	return ret;
}*/